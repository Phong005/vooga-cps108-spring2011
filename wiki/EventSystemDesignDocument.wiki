#summary Explains the essential concepts behind event-driven game development.
=Event System Design Document=

====Author: Ethan Yong-Hui Goh====

= Some of this information is out of date. It is still a good overview, but terms and details may have changed. We will try to update it soon. Thank you for your patience. =

= Introduction =

==Background and Definitions==
The Game Engine is designed to be event driven, meaning that specific triggering of events and invocation of their respective callbacks change the state of the Game, which in turn leads to another set of states based on other internal or external chain reactions. The important concept of designing an event system involves the thorough understanding of *Event Registration, Event Listeners* and *Event Callbacks*. As part of the preliminary steps before partaking in a detailed discussion of the design of the Event System, we will proceed to provide definitions for this terminology.

*Event Registration* is the act of keeping track of an Event, namely by attaching an 'unbiased' observer to it. This 'unbiased' observer is known as the *Event Listener*, which notifies a reactionary force that a signal has been received. This reactionary force is often called the *Event Handler* or the *Event Callback*.

==Examples of Event Driven Systems==
A physical example will be presented to accurately portray this concept. Imagine a world in a state of dynamic equilibrium, for example, an acid-base titration. Normally, if there are no external forces, the state (pH) of the chemical reaction will remain the same. To a scientist (Event Listener), an unbiased observer who wants to analyze the state of the reaction, would insert a probe into the solution (Triggers the Event) such as Phenolphthalein, which detects when the pH of the solution increases beyond 8.2. The scientist is 'listening' on a color change in the solution, and when it does, he will note the titration volume (Event Handling). In performing the reaction, the scientist adds stimulus to the system, namely adding base to the solution, disrupting the equilibrium of the solution. At some point in time, the pH of the solution will exceed 8.2, the solution will change color, triggering and Event that notifies the scientist, who will then handle and record the data as required. 

Event driven systems are exemplified by sensors such as trap doors or laser trip mines . In this case, event registration is the act of setting up a laser trip mine whose beam spans across the room. The trip mine listens on any moving object that comes in between the path of the mine. When this event is triggered, the mine handles this swiftly by exploding in the face of the intruder.

From this example, we have a basic design concept for a video game. One could easily imagine a maze game that requires one to navigate through trap filled room, whose traps are all registered in exact same fashion as described above. Explosions of laser mines could set of other adjacent mines, and lead to various other chain reactions that violently changes the state of the game.

==What this really means==
Classically, one could think of games as a temporal progression (time-driven engine) - i.e after a fixed amount of time, spawn enemies in top left corner; after the player's weapon charges up again, fire the weapon. All these things happen after a timer expires, and the forward progression in time drives the changes in game state. 

However, the key conceptual jump is abstracting time-driven engines by another level, noting and understanding that a the ticks of timers are merely specific events. By containment, we see that a time-driven engine is a subset of an event-based engine, making the event-driven system potentially much more powerful and extensible than the time-driven system, which is the justification for using an event-based system to drive this game engine.

Unfortunately, an event-system is not the panacea for all game design - the cost one pays for using an event-system is the multiple orders of increased complexity that comes with this additional design power. In order to bring order to the chaos that might ensue by making interconnections between events, this event system API strives to simplify, organize and process the events in a manner that is debuggable within reasonable time to an average human being. 


= Design =

==The Event Manager Class==

The Event Manager Class is the core of the Event System. It processes all event related things, such as event registration, firing of events, and handling of events. The interface to the Event Manager allows registration of Events of three types - basic event handlers, timed events, and every-turn events. 

==Event Registration==

===Basic Event Handlers===
Basic event handlers listen on a specific Event that will be fired in the future. Registration of this type requires the exact String name of the Event that it is listening on, and the callback method that is to be invoked upon receiving the event. 

{{{
public void registerEventHandler(String eventName, IEventHandler eventHandler);
}}}

===Timed Events===
There are two types of Timed Events - periodic and one-shot timer events. Periodic events are events that need to be fired at specific time intervals, for example, the activation of a player's weapon after a specified cooldown period. One-shot events on the other hand, are events that are only fired once at a specified time in the future, for example, starting a boss battle 30 seconds after the level has started.

In both cases, the interface two each type is similar. It requires the exact name of the Event to be fired, and the time delay between the firing of the event(s). 
{{{
public Timer addTimer (String eventName, long delay);  // one shot
public PeriodicTimer addPeriodicTimer (String eventName, long interval) // periodic
}}}

===Every-Turn Events===
Every-Turn Events are actions that need to be performed constantly by the game, for example, in collision detection or in the physics engine. Every-Turn events should not be explicitly fired by the user. 

{{{
public void addEveryTurnEvent(String eventName, IEventHandler eventHandler)
}}}

==Event Grouping and Naming==
Currently, groups of events are supported with globs, which serve as namespaces for the event group. This particular implementation may change in the later future, however, support of this feature will not disappear. 

Globs [http://en.wikipedia.org/wiki/Glob_(programming)] http://en.wikipedia.org/wiki/Glob_(programming)


==The Event Sandbox==
Any given Game State is contained in its own Event sandbox, connecting all the necessary events and external forces/inputs (e.g user interactions). This encapsulates a given state of the game, making it independent and modular, allowing the game to dynamically connect or disconnect from states during a state change.

The Event Sandbox can be thought of as a Stack of individual Sandbox-ed states. The game connects only to the top sandbox, meaning that all the functionality of the game is defined by only the top state. However, it is conceivable that certain new states might want to inherit from previous states, or completely override the event handlers that are in the previous states. Rather than forcing the user to remake all the connections every time there is a state change, we have attempted to provide a more useable interface that assists in this context switch. This introduces the concept of Blocking Sandboxes and Passthrough Sandboxes. 

===Blocking Sandbox===
A Blocking Sandbox is a type of Sandbox that inherits no event listeners from the previous state. It is a clean slate where the user must reconnect all the desired events. 

Usage Example: A Pause screen might want to use this type of Sandbox when layering a new game state. In a pause screen, all motion of the game in stopped, and control in limited to selection in the menu screen. It is more convenient to redefine all the keymappings and mouseover events from a clean state.

===Passthrough Sandbox===
On the other extreme, a Passthrough Sandbox is a type of Sandbox that inherits ALL event listeners from the previous state. It is a duplicate copy of the previous state where users might want to add additional functionality or override a few, not most of the the events.

Usage Example: A layered heads up display might use this type of Sandbox. In a game that uses the keyboard to control the player, one might want to add mouse support within the heads up display region where one could select items or weapons to use. This additional layer of mouse control is easier to add onto the existing state. 

===Somewhere in the middle Sandbox===
This is where we need input from all the other teams. Think about what events your component often connects or disconnects from system. Which ones more commonly remain? Are you able to categorize these events into a manageable fashion? Please let the Events team know. 

===Caveats===
There might exist a temptation for a Game creator to abuse the creation of sandbox states for some reason or another. Not every single state change in the game should deserve its own sandbox. I.e If a player collects a simple powerup that changes the user's weapon, this does not deserve a whole new sandbox state. Instead, the individual event should be added to the loop and deactivated when the powerful wears off. One must use his or her discretion when deciding when to create a new sandbox. For the most part, creating a new sandbox is warranted when a game enters an entirely new state that it needs to return to after the state is over - especially game-freezing menus. Do keep in mind that state changing is a costly operation, and that excessive and abusive use would lead to decreased performance of the game.

==The Reactor Pattern==
Reactor Pattern: [http://en.wikipedia.org/wiki/Reactor_pattern]http://en.wikipedia.org/wiki/Reactor_pattern

'nuf said... for now.

=Key Takeaways=

  # Events, Event Listeners, Event Handlers, Event Registration.
  # Event Sandbox
    # Blocking Sandbox
    # Passthrough Sandbox
  # Registering and Unregistering Events
  # Think about state changes in your component, and what type of sandbox might make your life easier.